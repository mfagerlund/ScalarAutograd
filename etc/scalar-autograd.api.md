## API Report File for "scalar-autograd"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

// @public
export class Adam extends Optimizer {
    constructor(trainables: Value[], opts?: AdamOptions);
    resetStateFor(trainable: Value): void;
    step(): void;
}

// @public
export interface AdamOptions extends OptimizerOptions {
    beta1?: number;
    beta2?: number;
    epsilon?: number;
}

// @public
export class AdamW extends Optimizer {
    constructor(trainables: Value[], opts?: AdamOptions);
    resetStateFor(trainable: Value): void;
    step(): void;
}

// @public
export type BackwardFn = () => void;

// @public
export class Losses {
    static binaryCrossEntropy(outputs: Value[], targets: Value[]): Value;
    static categoricalCrossEntropy(outputs: Value[], targets: number[]): Value;
    static EPS: number;
    static huber(outputs: Value[], targets: Value[], delta?: number): Value;
    static mae(outputs: Value[], targets: Value[]): Value;
    static mse(outputs: Value[], targets: Value[]): Value;
    static tukey(outputs: Value[], targets: Value[], c?: number): Value;
}

// @public
export interface NonlinearLeastSquaresOptions {
    // (undocumented)
    adaptiveDamping?: boolean;
    // (undocumented)
    costTolerance?: number;
    // (undocumented)
    dampingDecreaseFactor?: number;
    // (undocumented)
    dampingIncreaseFactor?: number;
    // (undocumented)
    gradientTolerance?: number;
    // (undocumented)
    initialDamping?: number;
    // (undocumented)
    lineSearchSteps?: number;
    // (undocumented)
    maxInnerIterations?: number;
    // (undocumented)
    maxIterations?: number;
    // (undocumented)
    paramTolerance?: number;
    // (undocumented)
    trustRegionRadius?: number;
    // (undocumented)
    useQR?: boolean;
    // (undocumented)
    verbose?: boolean;
}

// @public
export interface NonlinearLeastSquaresResult {
    // (undocumented)
    computationTime: number;
    // (undocumented)
    convergenceReason: string;
    // (undocumented)
    finalCost: number;
    // (undocumented)
    functionEvaluations?: number;
    // (undocumented)
    iterations: number;
    // (undocumented)
    success: boolean;
}

// @public
export abstract class Optimizer {
    constructor(trainables: Value[], learningRate: number);
    clipGradients(maxNorm: number): void;
    learningRate: number;
    abstract resetStateFor(trainable: Value): void;
    abstract step(): void;
    protected trainables: Value[];
    zeroGrad(): void;
}

// @public
export interface OptimizerOptions {
    gradientClip?: number;
    learningRate?: number;
    weightDecay?: number;
}

// @public
export class SGD extends Optimizer {
    constructor(trainables: Value[], opts?: OptimizerOptions);
    resetStateFor(trainable: Value): void;
    step(): void;
}

// @public
export class V {
    static abs(a: Value | number): Value;
    static acos(x: Value | number): Value;
    static add(a: Value | number, b: Value | number): Value;
    static asin(x: Value | number): Value;
    static atan(x: Value | number): Value;
    static C(value: number, label?: string): Value;
    static ceil(a: Value | number): Value;
    static clamp(a: Value | number, min: number, max: number): Value;
    // Warning: (ae-forgotten-export) The symbol "CompiledFunctions" needs to be exported by the entry point Value.d.ts
    static compileObjective(params: Value[], objectiveFn: (params: Value[]) => Value): CompiledFunctions;
    static cos(x: Value | number): Value;
    static cube(a: Value | number): Value;
    static div(a: Value | number, b: Value | number, eps?: number): Value;
    static eq(a: Value | number, b: Value | number): Value;
    static exp(a: Value | number): Value;
    static floor(a: Value | number): Value;
    static gt(a: Value | number, b: Value | number): Value;
    static gte(a: Value | number, b: Value | number): Value;
    static ifThenElse(cond: Value | number, thenVal: Value | number, elseVal: Value | number): Value;
    static log(a: Value | number, eps?: number): Value;
    static lt(a: Value | number, b: Value | number): Value;
    static lte(a: Value | number, b: Value | number): Value;
    static max(a: Value | number, b: Value | number): Value;
    static mean(vals: (Value | number)[]): Value;
    static min(a: Value | number, b: Value | number): Value;
    static mod(a: Value | number, b: Value | number): Value;
    static mul(a: Value | number, b: Value | number): Value;
    static neg(a: Value | number): Value;
    static neq(a: Value | number, b: Value | number): Value;
    static nonlinearLeastSquares(params: Value[], residualFn: (params: Value[]) => Value[], options?: NonlinearLeastSquaresOptions): NonlinearLeastSquaresResult;
    static Param(value: number, paramName: string): Value;
    static pow(a: Value | number, exp: number): Value;
    static powValue(a: Value | number, b: Value | number, eps?: number): Value;
    static reciprocal(a: Value | number, eps?: number): Value;
    static relu(x: Value | number): Value;
    static round(a: Value | number): Value;
    static sigmoid(x: Value | number): Value;
    static sign(a: Value | number): Value;
    static sin(x: Value | number): Value;
    static softplus(x: Value | number): Value;
    static sqrt(a: Value | number): Value;
    static square(a: Value | number): Value;
    static sub(a: Value | number, b: Value | number): Value;
    static sum(vals: (Value | number)[]): Value;
    static tan(x: Value | number): Value;
    static tanh(x: Value | number): Value;
    static W(value: number, label?: string): Value;
}

// @public
export class Value {
    constructor(data: number, label?: string, requiresGrad?: boolean);
    abs(): Value;
    acos(): Value;
    add(other: Value | number): Value;
    asin(): Value;
    atan(): Value;
    backward(zeroGrad?: boolean): void;
    ceil(): Value;
    clamp(min: number, max: number): Value;
    cos(): Value;
    cube(): Value;
    data: number;
    div(other: Value | number): Value;
    eq(other: Value): Value;
    exp(): Value;
    floor(): Value;
    // (undocumented)
    getBackwardCode(gradVar: string, childGrads: string[], childVars: string[]): string;
    // (undocumented)
    getForwardCode(childCodes: string[]): string;
    grad: number;
    gt(other: Value): Value;
    gte(other: Value): Value;
    label: string;
    log(): Value;
    lt(other: Value): Value;
    lte(other: Value): Value;
    static make(data: number, left: Value, right: Value | null, backwardFnBuilder: (out: Value) => BackwardFn, label: string, op?: string): Value;
    static makeNary(data: number, inputs: Value[], backwardFnBuilder: (out: Value) => BackwardFn, label: string, op?: string): Value;
    max(other: Value): Value;
    static mean(vals: Value[]): Value;
    min(other: Value): Value;
    mod(other: Value): Value;
    mul(other: Value | number): Value;
    neg(): Value;
    neq(other: Value): Value;
    static no_grad_mode: boolean;
    // @internal
    _op?: string;
    // @internal
    _opConstants?: number[];
    // @internal
    paramName?: string;
    pow(exp: number): Value;
    powValue(other: Value | number): Value;
    // @internal (undocumented)
    prev: Value[];
    reciprocal(): Value;
    // @internal
    _registryId?: number;
    relu(): Value;
    requiresGrad: boolean;
    round(): Value;
    sigmoid(): Value;
    sign(): Value;
    sin(): Value;
    softplus(): Value;
    square(): Value;
    sub(other: Value | number): Value;
    static sum(vals: Value[]): Value;
    tan(): Value;
    tanh(): Value;
    toString(): string;
    static withNoGrad<T>(fn: () => T): T;
    static zeroGradAll(vals: Value[]): void;
    static zeroGradTree(root: Value): void;
}

// @public
export class Vec2 {
    constructor(x: Value | number, y: Value | number);
    // (undocumented)
    add(other: Vec2): Vec2;
    static angleBetween(a: Vec2, b: Vec2): Value;
    // (undocumented)
    static C(x: number, y: number): Vec2;
    static cross(a: Vec2, b: Vec2): Value;
    static distanceToLine(point: Vec2, lineStart: Vec2, lineEnd: Vec2): Value;
    // (undocumented)
    div(scalar: Value | number): Vec2;
    // (undocumented)
    static dot(a: Vec2, b: Vec2): Value;
    // (undocumented)
    get magnitude(): Value;
    // (undocumented)
    mul(scalar: Value | number): Vec2;
    // (undocumented)
    get normalized(): Vec2;
    // (undocumented)
    static one(): Vec2;
    get perpendicular(): Vec2;
    // (undocumented)
    get sqrMagnitude(): Value;
    // (undocumented)
    sub(other: Vec2): Vec2;
    // (undocumented)
    toString(): string;
    // (undocumented)
    get trainables(): Value[];
    // (undocumented)
    static W(x: number, y: number): Vec2;
    // (undocumented)
    x: Value;
    // (undocumented)
    y: Value;
    // (undocumented)
    static zero(): Vec2;
}

// @public
export class Vec3 {
    constructor(x: Value | number, y: Value | number, z: Value | number);
    // (undocumented)
    add(other: Vec3): Vec3;
    static angleBetween(a: Vec3, b: Vec3): Value;
    // (undocumented)
    static C(x: number, y: number, z: number): Vec3;
    clone(): Vec3;
    // (undocumented)
    static cross(a: Vec3, b: Vec3): Vec3;
    static distance(a: Vec3, b: Vec3): Value;
    // (undocumented)
    div(scalar: Value | number): Vec3;
    // (undocumented)
    static dot(a: Vec3, b: Vec3): Value;
    static fromData(x: number, y: number, z: number): Vec3;
    static lerp(a: Vec3, b: Vec3, t: Value | number): Vec3;
    // (undocumented)
    get magnitude(): Value;
    static max(a: Vec3, b: Vec3): Vec3;
    static min(a: Vec3, b: Vec3): Vec3;
    // (undocumented)
    mul(scalar: Value | number): Vec3;
    // (undocumented)
    get normalized(): Vec3;
    // (undocumented)
    static one(): Vec3;
    static project(a: Vec3, b: Vec3): Vec3;
    static reject(a: Vec3, b: Vec3): Vec3;
    static sqrDistance(a: Vec3, b: Vec3): Value;
    // (undocumented)
    get sqrMagnitude(): Value;
    // (undocumented)
    sub(other: Vec3): Vec3;
    toArray(): number[];
    // (undocumented)
    toString(): string;
    // (undocumented)
    get trainables(): Value[];
    // (undocumented)
    static W(x: number, y: number, z: number): Vec3;
    // (undocumented)
    x: Value;
    // (undocumented)
    y: Value;
    // (undocumented)
    z: Value;
    // (undocumented)
    static zero(): Vec3;
}

// (No @packageDocumentation comment for this package)

```
